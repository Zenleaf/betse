#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright 2014-2016 by Alexis Pietak & Cecil Curry.
# See "LICENSE" for further details.

'''
BETSE-specific monkey patching of `setuptools`'s `ScriptWriter` class.

Such patching renders such class for use with editable installations of Python
packages (e.g., via BETSE's `symlink` command). The default `ScriptWriter`
implementation writes scripts attempting to import the `setuptools`-installed
package resources for such packages. Since no such resources are installed for
editable installations, such scripts *always* fail and hence are suitable *only*
for use with user-specific venvs.

Such patching corrects this deficiency, albeit at a minor cost of ignoring the
package resources provided by Python packages installed in the customary way.
While there exist alternatives, this appears to be the most robust means of
maintaining backward compatibility with older `setuptools` versions.
'''

# ....................{ IMPORTS                            }....................
from distutils.errors import DistutilsClassError
from pkg_resources import Distribution
from betse_setup import util
from setuptools.command import easy_install
from setuptools.command.easy_install import ScriptWriter, WindowsScriptWriter

# ....................{ CONSTANTS                          }....................
SCRIPT_TEMPLATE = '''
# Auto-generated by the "build_scripts" setuptools command.
import importlib, sys

def is_module_root(module_name: str) -> bool:
    """
    `True` if the **top-level module** (i.e., module whose name contains no `.`
    characters) with the passed fully-qualified name is importable under the
    active Python interpreter.

    If this module is _not_ importable via the standard
    `importlib.find_loader()` mechanism (e.g., the OS X-specific `PyObjCTools`
    package), this module may also be imported as an additional side effect.
    """
    assert isinstance(module_name, str), (
        '"{{}}" not a string.'.format(module_name))

    # If this is *NOT* a top-level module, raise an exception.
    if '.' in module_name:
        raise ImportError('Module "{{}}" not a top-level module.'.format(
            module_name))

    # See betse.util.python.modules.is_module() for implementation details.
    try:
        return importlib.find_loader(module_name) is not None
    except ValueError:
        try:
            importlib.import_module(module_name)
            return True
        except ImportError:
            return False

# If this script is imported by another module rather than run directly,
# noop by printing a non-fatal warning and then returning. While this script
# should *NEVER* be imported, contemptible edge cases do happen.
# Else, this script is run directly. Let's do this.
if __name__ == '__main__':
    # If the root parent package of this entry module is unimportable, raise a
    # human-readable exception. For inscrutable reasons, testing for whether
    # this entry module itself is importable is highly non-trivial under Python
    # 3.3 but *NOT* Python >= 3.4. While requiring Python >= 3.4 above would
    # obviate this, such version requirements are best asserted in the main
    # application codebase. Instead, we defer to the next best test.
    if not is_module_root('{entry_package_root}'):
        raise ImportError(
            'Package "{entry_package_root}" unimportable. Consider running either:\\n'
            '\\tsudo python3 setup.py install\\n'
            '\\tsudo python3 setup.py symlink')

    # Import the entry module.
    import {entry_module} as entry_module

    # For debugging purposes, print the absolute path of this module.
    #print('{entry_module}: ' + entry_module.__file__)
    {entry_func_code}
# If this script is imported by another module rather than run directly,
# noop by printing a non-fatal warning and then returning. While this script
# should *NEVER* be imported, contemptible edge cases do happen.
# Else, this script is run directly. Let's do this.
else:
    print('WARNING: Entry point imported rather than run.', file=sys.stderr)
'''
'''
Script template to be formatted by `ScriptWriterSimple.get_script_args()`.
'''

SCRIPT_ENTRY_FUNC_SUBTEMPLATE = '''
    # If this module requires an entry function to be run, call such function.
    # For POSIX compliance, the value returned by this function (ideally a
    # single-byte integer) will be propagated back to the calling shell as this
    # script's exit status.
    sys.exit(entry_module.{entry_func}())
'''
'''
Script subtemplate to be formatted by `ScriptWriterSimple.get_script_args()`
for entry points requiring an entry function to be called.

This excludes entry points for which merely importing the desired entry module
suffices to implicitly run that entry point -- typically, entry modules with
basename `__main__`.
'''

# ....................{ COMMANDS                           }....................
def add_setup_commands(metadata: dict, setup_options: dict) -> None:
    '''
    Add commands building distribution entry points to the passed dictionary of
    `setuptools` options.
    '''
    assert isinstance(setup_options, dict),\
        '"{}" not a dictionary.'.format(setup_options)

    # If neither of the class functions monkey-patched below exist, setuptools
    # is either broken or an unsupported newer version. In either case, an
    # exception is raised.
    if not hasattr(ScriptWriter, 'get_args') and\
       not hasattr(ScriptWriter, 'get_script_args'):
        raise DistutilsClassError('Class "setuptools.command.easy_install.ScriptWriter" functions get_args() and get_script_args() not found. The current version of setuptools is either broken (unlikely) or unsupported (likely).')

    # Monkey-patch the following class functions:
    #
    # * ScriptWriter.get_args(), defined by recent versions of setuptools.
    # * ScriptWriter.get_script_args(), defined by obsolete versions of
    #   setuptools.
    #
    # For convenience, our implementation of the latter is implemented in terms
    # of the former. Hence, the former is *ALWAYS* monkey-patched.
    ScriptWriter.get_args = _get_args

    # If the ScriptWriter.get_script_args() class function exists, monkey-patch
    # both that *AND* the setuptools.command.easy_install.get_script_args()
    # alias referring to that function as well.
    if hasattr(ScriptWriter, 'get_script_args'):
        ScriptWriter.get_script_args = _get_script_args
        easy_install.get_script_args = ScriptWriter.get_script_args

        # If the ScriptWriter.get_script_header() class function does *NOT*
        # exist, monkey-patch that function as well.
        if not hasattr(ScriptWriter, 'get_script_header'):
            ScriptWriter.get_script_header = _get_script_header

# ....................{ PATCHES                            }....................
# Functions monkey-patching existing methods of the "ScriptWriter" class above
# and hence defined to have the same method signatures. The "cls" parameter
# implicitly passed to such methods by the @classmethod decorator is guaranteed
# to be the "ScriptWriter" class.

@classmethod
def _get_args(
    cls: type,
    distribution: Distribution,
    script_shebang: str = None
):
    '''
    Yield `write_script()` argument tuples for the passed distribution's **entry
    points** (i.e., platform-specific executables running such distribution).

    This function monkey-patches the `ScriptWriter.get_args()` class function.
    '''
    # Default such shebang line if unpassed.
    if script_shebang is None:
        script_shebang = cls.get_header()

    assert isinstance(cls, type), '"{}" not a class.'.format(cls)
    assert isinstance(script_shebang, str),\
        '"{}" not a string.'.format(script_shebang)
    #print('In BETSE ScriptWriter.get_args()!')

    # For each entry point...
    for script_basename, script_type, entry_point in\
        util.package_distribution_entry_points(distribution):
        # Script code calling the main function in this entry module to be
        # called if any or the empty string otherwise.
        if len(entry_point.attrs):
            script_entry_func_code = SCRIPT_ENTRY_FUNC_SUBTEMPLATE.format(
                entry_func = entry_point.attrs[0])
        else:
            script_entry_func_code = ''

            # Print a non-fatal warning, as the resulting script may *NOT*
            # necessarily be runnable or freezable as expected.
            util.output_warning(
                'Entry module "{}" entry function undefined.'.format(
                entry_point.module_name))

        # Script contents, formatted according to such template.
        script_code = SCRIPT_TEMPLATE.format(
            entry_func_code = script_entry_func_code,

            # Fully-qualified name of this entry module's root parent package.
            entry_package_root = entry_point.module_name.split('.')[0],

            # Fully-qualified name of this entry module.
            entry_module = entry_point.module_name,
        )

        # Yield a tuple containing such metadata to the caller.
        for script_tuple in cls._get_script_args(
            script_type, script_basename, script_shebang, script_code):
            yield script_tuple

@classmethod
def _get_script_args(
    cls: type,
    distribution: Distribution,
    executable = None,
    is_windows_vanilla: bool = False
):
    '''
    Yield `write_script()` argument tuples for the passed distribution's **entry
    points** (i.e., platform-specific executables running such distribution).

    This function monkey-patches the deprecated
    `ScriptWriter.get_script_args()` class function.
    '''
    assert isinstance(cls, type), '"{}" not a class.'.format(cls)
    print('In BETSE ScriptWriter.get_script_args()!')

    # Platform-specific entry point writer.
    #
    # If the newer ScriptWriter.best() class function exists, obtain such
    # writer by calling this function.
    script_writer = None
    if hasattr(ScriptWriter, 'best'):
        script_writer = (
            WindowsScriptWriter if is_windows_vanilla else ScriptWriter).best()
    # Else, obtain such writer by calling the older ScriptWriter.get_writer()
    # class function.
    else:
        script_writer = cls.get_writer(is_windows_vanilla)

    # Shebang line prefixing the contents of all such scripts.
    script_shebang = cls.get_script_header(
        '', executable, is_windows_vanilla)

    # Defer to the newer _get_args() function.
    return script_writer.get_args(distribution, script_shebang)


@classmethod
def _get_script_header(cls: type, *args, **kwargs):
    '''
    Defer to the deprecated
    `setuptools.command.easy_install.get_script_header()` function under older
    versions of setuptools.
    '''
    from setuptools.command.easy_install import get_script_header
    return get_script_header(*args, **kwargs)
