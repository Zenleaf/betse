#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright 2014-2015 by Alexis Pietak & Cecil Curry
# See "LICENSE" for further details.

'''
Low-level directory facilities.

This module is named `dirs` rather than `dir` to avoid conflict with the `dir()`
builtin.
'''

# ....................{ IMPORTS                            }....................
from betse import metadata
from betse.util.exceptions import BetseExceptionDir
from betse.util.system import systems
from os import environ, path
import os, sys

# ....................{ CONSTANTS                          }....................
#FIXME: Replace all existing calls to os.path.expanduser() with such constant.

HOME_DIRNAME = path.expanduser('~')
'''
Absolute path of the current user's home directory.
'''

# ....................{ CONSTANTS ~ data                   }....................
DATA_DIRNAME = ''   # initialized below
'''
Absolute path of `betse`'s data directory.

Such directory contains application-internal resources (e.g., media files)
frozen with the end-user executable binaries generated by PyInstaller.
'''

# ....................{ CONSTANTS ~ dot                    }....................
DOT_DIRNAME = ''  # initialized below
'''
Absolute path of `betse`'s dot directory in the current user's home directory.

Such directory contains application-external resources (e.g., configuration
files) created at application runtime and subsequently editable by external
users and utilities.

Locations
----------
This path is operating system-specific as follows:

* Under Linux, this is `~/.betse/`. `betse` does *not* currently comply with the
  _XDG Base Directory Specification (e.g., `~/.local/share/betse`), which the
  principal authors of `betse` largely regard as unhelpful.
* Under OS X, this is `~/Library/Application Support/BETSE`.
* Under Windows, this is
  `C:\Documents and Settings\${User}\Application Data\BETSE`.

.. _XDG Base Directory Specification: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
'''

# ....................{ INITIALIZATION                     }....................
def __init__():
    '''
    Initialize constants whose definitions depend on conditional runtime state.

    To support caller-specific exception handling, this function does *not*
    validate such constants (e.g., by creating non-existent directories). See
    `paths.init()` for such functionality.
    '''
    # Declare such constants to be globals, permitting their modification below.
    global DATA_DIRNAME, DOT_DIRNAME

    # Relative path of the top-level data directory.
    data_dirname_main = 'data'

    # Initialize the absolute path of the data directory.
    #
    # If the current application is a PyInstaller-frozen executable binary, the
    # bootloader for such binary will have added the PyInstaller-specific private
    # attribute "_MEIPASS" to the "sys" module, providing the absolute path of the
    # temporary directory containing all application data resources.
    if hasattr(sys, '_MEIPASS'):
        #FIXME: Is this right? Verify with additional online research.
        DATA_DIRNAME = path.join(sys._MEIPASS, data_dirname_main)
    #FIXME: This *OBVIOUSLY* isn't right. We appear to have two options,
    #depending on how "betse" was installed:
    #
    #* If via "setup.py install", we should probably use "pkg_resources" to
    #  obtain the data directory.
    #* Else, assume it was via "setup.py symlink", in which case the data
    #  directory can probably be located in one of two ways (in order of
    #  inreasing complexity):
    #  * Use the "__file__" attribute of the current module to obtain the
    #    absolute path of such module. Given that, we can then obtain the
    #    absolute path of the data directory via path munging and the
    #    os.path.abspath(pathname) function, converting relative to absolute
    #    paths. (Double-check that, of course.)
    #  * Manually follow the symlink at
    #    "/usr/lib64/python3.3/site-packages/betse". Yeah. That seems horrid.
    #    Happily, the former approach should work.
    else:
        DATA_DIRNAME = data_dirname_main

    # Initialize the absolute path of the dot directory.
    #
    # If the current system is OS X, set such directory accordingly.
    if systems.is_osx():
        DOT_DIRNAME = path.join(
            HOME_DIRNAME,
            'Library', 'Application Support',
            metadata.SCRIPT_NAME_CLI
        )
    # If the current system is Windows, set such directory accordingly.
    elif systems.is_windows():
        DOT_DIRNAME = path.join(environ['APPDATA'], metadata.NAME)
    #FIXME: Explicitly assert POSIX compatibility here.
    # Else, assume the current system is POSIX-compatible.
    else:
        DOT_DIRNAME = path.join(HOME_DIRNAME, '.' + metadata.SCRIPT_NAME_CLI)

# ....................{ EXCEPTIONS                         }....................
def die_unless_found(dirname: str) -> None:
    '''
    Raise an exception unless the passed directory exists.
    '''
    assert isinstance(dirname, str), '"{}" not a string.'.format(dirname)
    if not is_dir(dirname):
        raise BetseExceptionDir(
            'Directory "{}" not found or not a readable directory.'.format(
                dirname))

def die_unless_parent_found(pathname: str) -> None:
    '''
    Raise an exception unless the parent directory of the passed path exists.
    '''
    assert isinstance(pathname, str), '"{}" not a string.'.format(pathname)
    die_unless_found(get_dirname(pathname))

# ....................{ TESTERS                            }....................
def is_dir(dirname: str) -> bool:
    '''
    True if the passed directory exists.
    '''
    assert isinstance(dirname, str), '"{}" not a string.'.format(dirname)
    return path.isdir(dirname)

# ....................{ GETTERS                            }....................
def get_dirname(pathname: str) -> str:
    '''
    Get the *dirname* (i.e., parent directory) of the passed path.
    '''
    assert isinstance(pathname, str), '"{}" not a string.'.format(pathname)
    return path.dirname(pathname)

# ....................{ JOINERS                            }....................
def join(*pathnames) -> str:
    '''
    Join the passed pathnames on the directory separator specific to the current
    operating system.

    This is a convenience function wrapping the standard `os.path.join()`
    function, provided to reduce the number of import statements required by
    other modules.
    '''
    return path.join(*pathnames)

# ....................{ MAKERS                             }....................
#FIXME: Replace all existing calls to os.makedirs() by calls to such functions.

def make_unless_found(dirname: str) -> None:
    '''
    Create the passed directory if such directory does *not* already exist.

    All nonexistent parents of such directory will also be recursively created,
    mimicking the action of the conventional shell command `mkdir -p`.
    '''
    assert isinstance(dirname, str), '"{}" not a string.'.format(dirname)
    os.makedirs(dirname, exist_ok = True)

def make_parent_unless_found(*pathnames) -> None:
    '''
    Create the parent directory of each passed path for parent directories that
    do *not* already exist.
    '''
    for pathname in pathnames:
        make_unless_found(get_dirname(pathname))

# --------------------( WASTELANDS                         )--------------------
# from betse.util.path import paths
