#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright 2015 by Alexis Pietak & Cecil Curry
# See "LICENSE" for further details.

'''
Low-level module facilities.
'''

# ....................{ IMPORTS                            }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: To raise human-readable exceptions on missing mandatory dependencies,
# the top-level of this module may import *ONLY* from packages guaranteed to
# exist at installation time (e.g., BETSE packages, stock Python packages).
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
from betse.exceptions import BetseExceptionModule
import importlib, sys

# ....................{ EXCEPTIONS                         }....................
def die_unless(
    module_name: str, exception_message: str = None) -> None:
    '''
    Raise an exception with the passed message (defaulting to a message
    synthesized from the passed module name) if the module with the passed name
    is *not* importable.

    If such module is a **submodule** (i.e., contains a `.` character), all
    parent modules of such module will be imported as a side effect of this
    function call.
    '''
    # If such module is missing, raise an exception.
    if not is_module(module_name):
        # If no exception message was passed, synthesize one from such name.
        if not exception_message:
            exception_message = 'Module "{}" not found.'.format(module_name)
        assert isinstance(exception_message, str),\
            '"{}" not a string.'.format(exception_message)

        # Raise such exception.
        raise BetseExceptionModule(exception_message)

# ....................{ TESTERS                            }....................
#FIXME: importlib.find_loader() has been deprecated by
#importlib.util.find_spec() in Python 3.4. After migrating all developer
#machines to the latter, call the latter below instead.

def is_module(module_name: str) -> bool:
    '''
    True if the module with the passed name is importable under the active
    Python 3 interpreter.

    If such module is a **submodule** (i.e., contains a `.` character), all
    parent modules of such module will be imported as a side effect of this
    function call. Likewise, if such module is *not* importable via the
    standard `importlib.find_loader()` mechanism (e.g., as is the case for the
    OS X-specific package `PyObjCTools`), such module will also be imported as
    an additional side effect.
    '''
    assert isinstance(module_name, str),\
        '"{}" not a string.'.format(module_name)

    # Depending on context, importlib.find_loader() operates in one of three
    # distinct ways:
    #
    # * If such module's name is a key in the canonical dictionary "sys.modules"
    #   and has thus already been imported at least once under the current
    #   Python process, then...
    #   * If the "sys.modules[module_name].__spec__" attribute is set to a non-
    #     None value, such value is returned.
    #   * Else, the "ValueError" exception is raised.
    # * Else if such module is found by physically searching "sys.meta_path", a
    #   new spec is created describing such module and returned.
    # * Else, None is returned.
    #
    # However, this function only returns a single boolean and hence converts
    # such return values and exceptions to appropriate boolean values.
    try:
        return importlib.find_loader(module_name) is not None
    # Unfortunately, such exception does *NOT* necessarily imply such module        # to be missing, warranting further introspection. Unfortunately, such
    # exception does imply that conventional alternatives to the prior function
    # call (e.g., testing tuples generated by pkgutil.iter_modules()) will also
    # fail to find such module.
    #
    # We have no recourse but to fallback to attempting to manually import such
    # module. Since such importation could have unexpected side effects, we do
    # so *ONLY* in this edge case.
    except ValueError:
        try:
            importlib.import_module(module_name)
            return True
        except ImportError:
            return False

def is_imported(*module_names) -> bool:
    '''
    True if all modules with the passed names have already been imported at
    least once by the current process.
    '''
    for module_name in module_names:
        assert isinstance(module_name, str),\
            '"{}" not a string.'.format(module_name)
        if module_name not in sys.modules:
            return False
    return True

# ....................{ GETTERS                            }....................
def get_dirname(mod) -> str:
    '''
    Get the absolute path of the directory containing the Python script from
    which the passed module was previously imported.
    '''
    assert hasattr(mod, '__file__'), '"{}" not a module.'.format(mod)

    # Avoid circular import dependencies.
    from betse.util.path import paths

    # Get such dirname.
    return paths.get_dirname(mod.__file__)

# --------------------( WASTELANDS                         )--------------------
        # If such module contains no "." characters and is hence a top-level
        # module, such module exists if and only if such module's name is the
        # second element of a tuple generated by pkgutil.iter_modules().
#       if '.' not in module_name:
            # For efficiency, generate a temporary dictionary whose keys are
            # the names of all top-level modules and then test whether the
            # passed module name is a key of such dictionary. (Since this is
            # Python, this is actually more efficient than iterative testing.)
#           return module_name in {
#               (module_name_curr, None)
#               for module_finder, module_name_curr, module_is_package in\
#                   pkgutil.iter_modules()
#           }
        #FIXME: Actually, we do have an alternative here. We may use
        #pkgutil.walk_packages() to walk the top-level package containing such
        #module. Such function imports *ONLY* such package and hence is
        #relatively safe.

#FUXME: Constrain such function to *ONLY* test top-level module names (i.e.,
#module names containing *NO* "." characters), and rename to is_module_root().
#The reason? The documentation for find_loader() notes that:
#"If name is for a submodule (contains a dot), the parent module is
# automatically imported."
    # Such module is assumed to signify a mandatory `betse` dependency. Likewise,
    # such requirements are assumed to be in `setuptools` format (e.g.,
    # `numpy >= 1.9.0`).

#  Ideally, such
    # exception would be an instance of the setuptools-specific
    # "DistributionNotFound" class. Yet, as setuptools and hence such class is
    # *NOT* guaranteed to be importable, the conventional Python exception for
    # import errors is raised instead.
        # if not importlib.find_loader(requirement.project_name):
        #     raise DistributionNotFound(
        #         'Mandatory dependency {} not found.'.format(requirement))
    # for module_name in {
    #     'scipy'
    # }:
    # For each such dependency, this function also attempts to validate such
    # dependency's version. Specifically, if such dependency both exists *and*,
    # an exception is raised if

    # Caveats
    # ----------
    # Dependency versions are *not* validated. This is subject to change
